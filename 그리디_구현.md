# 그리디 알고리즘
- 현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미
- 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구
- 최적의 해를 보장할 수 없을때가 많음

당신은 음식점의 계산을 도와주는 점원, 카운터에서는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재  
손님에게 거슬러 주어야 할 돈이 N원 일 때 거슬러 주어야 할 동전의 최소 개수를 구하세요.(단 거슬러 줘야 할 돈 N은 항상 10의 배수)  

- 최적의 해를 빠르게 구하기 위해서 -> 가장 큰 화폐 단위부터 계산

```
n = 1260
count = 0
array = [500, 100, 50, 10]

for coin in array:
    count += n // coin
    n %= coin
print(count)

```

## 문제 : 1이 될 때 까지
- 어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행, 단, 두번째 연산은 N이 K로 나누어 떨어질 때만 선택
    1. N에서 1을 뺍니다.
    2. N을 K로 나눕니다. 

- 입력 조건 : 첫째 줄에 N( 1<= N <= 100000)과 K(2 <= K <= 100000)가 공백을 기준으로 하여 각각 자연수로 주어짐
- 출력 조건 : 첫째 줄에 N이 1이 될 때가지 1번 혹은 2번의 과정을 수행해야 하는 횟수의 최솟값을 출력
- 해결 아이디어
    - 주어진 N에 대하여 최대한 많이 나누기를 수행
    - N의 값을 줄일 때 2 이상의 수로 나누는 작업이 1을 빼는 작업보다 수를 훨씬 많이 줄임  

```
# n, k를 공백을 기준으로 구분하여 입력 받기
n, k = map(int, input().split())

result = 0

while True:
  # N이 K로 나누어 떨어지는 수가 될때까지 빼기
  target = (n // k) * k
  result += (n - target)
  n = target

  # N이 K보다 작을 때 (더 이상 나눌 수 없을 때) 반복문 탈출
  if n < k:
    break;

  result += 1
  n //= k

result += (n - 1)
print(result)
```

## 문제 : 곱하기 혹은 더하기 
- 각 자리가 숫자(0~9)로만 이루어진 문자열 S
- 왼쪽부터 오른쪽으로 하나씩 모든 숫자 확인하여 'x', '+' 연산자 넣어 만들어질수 있는 가장 큰 수를 구하는 프로그램
- +보다 x를 먼저 계산하는 방식과는 달리, 왼쪽에서부터 순서대로 연산순서 이루어짐
- 20억 이하의 정수 (int 자료구조형)
- 입력 조건 : 첫째 줄에 여러 개의 숫자로 구성된 하나의 문자열 S가 주어짐
- 출력 조건 : 첫째 줄에 만들어질 수 있는 가장 큰 수를 출력
02984 -> 576
567 -> 210

- 일반적인 수 : 곱하기 > 더하기 
- 두 수 중에서 하나라도 0 혹은 1인 경우 : 곱하기 < 더하기
- 정답 : 두 수 중에서 하나라도 1 이하인 경우 더하기, 2 이상인 경우 곱하기

```
data = input()

# 첫 번째 문자를 숫자로 변경하여 대임
result = int(data[0])

for i in range(1, len(data)):
  num = int(data[i])
  if(num <=1 or result <= 1):
    result += num
  else:
    result *= num

print(result)
```

## 문제 : 모험가 길드
- 한 마을에 모험가가 N명이 있음, N명의 모험가를 대상으로 공포도 측정
- 공포도가 X인 모험가는 반드시 X명 이상으로 구성한 그룹에 참여 -> 여행 가능
- 최대 몇 개의 모험가 그룹을 만들 수 있는지 





